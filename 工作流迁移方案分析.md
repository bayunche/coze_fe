# 前端项目工作流架构分析及迁移方案

## 项目概述

基于对代码的深入分析，发现项目存在一个严重的架构问题：**使用两套完全不同的架构处理同类型的业务**！这确实需要整改。

## 当前架构现状

### 🔴 问题工作流（直接调用 Coze API）

#### 1. 合同解析 (`contractParsing`)
- **工作流 ID**: `7516796514431172642`
- **实现方式**: 直接调用 Coze API，依赖外部服务
- **文件上传**: 上传到 Coze 服务器
- **问题**: 流式响应处理复杂，容错性差

#### 2. 乙供物资解析 (`supplierMaterialParsing`) 
- **工作流 ID**: `7517934954761715721`
- **实现方式**: 同样直接调用 Coze API
- **问题**: 参数格式与合同解析略有不同，维护复杂

### ✅ 已优化工作流（后端 API）

#### 3. 甲供物资解析 (`ownerSuppliedMaterialParsing`)
- **实现方式**: 使用后端 API `/backend-api/v1/chat/generate`
- **文件上传**: 上传到自己的服务器 `/api/files/upload`
- **优势**: 统一的流式响应处理，更好的错误处理和用户体验

## 核心问题分析

### 架构不一致导致的问题

1. **维护成本高**: 两套不同的错误处理、进度管理逻辑
2. **用户体验不一致**: 响应格式、错误提示各不相同  
3. **依赖风险**: 直接调用 Coze API 存在服务稳定性风险
4. **扩展困难**: 无法统一添加业务逻辑，如权限控制、日志记录等

### 技术债务

- 前两个工作流直接依赖 Coze API
- 后一个已经通过后端封装
- 三个类似功能用了两套完全不同的实现

## 迁移方案

### 第一步：后端 API 扩展

后端需要新增两个 `agentManagementId`：

```javascript
// 现有：
// agentManagementId: '2' - 甲供物资解析
// agentManagementId: '4' - 甲供物资重新解析

// 新增：
// agentManagementId: '1' - 合同解析  
// agentManagementId: '3' - 乙供物资解析
```

### 第二步：前端代码修改

需要修改 `src/stores/workflow.js` 中的执行函数：

#### 合同解析迁移

```javascript
// 原来：executeContractParsing() 调用 CozeParsingService
// 改为：类似 executeOwnerMaterialParsing() 的模式

const executeContractParsing = async (inputs, context) => {
  const { workflow, loadingMessage, addMessageCallback } = context
  const finalResult = []

  const streamingAgentMessage = {
    id: Date.now() + Math.random(),
    from: 'agent',
    content: '',
    timestamp: new Date().toLocaleTimeString(),
    sender: workflow.name,
    workflow: { id: workflow.id, name: workflow.name },
    isStreaming: true
  }

  try {
    loadingMessage.content = '合同解析已开始...'
    addMessageCallback(streamingAgentMessage)

    // 使用后端 API，agentManagementId: '1'
    await callStreamWorkflow(inputs, '1', {
      onMessage: (event) => {
        if (event.content) {
          // 处理流式消息
          chatStore.appendStreamContent(streamingAgentMessage.id, event.content)
          finalResult.push(event.content)
        }
      },
      onError: (error) => {
        onExecutionError(error, loadingMessage, addMessageCallback)
      },
      onComplete: () => {
        delete streamingAgentMessage.isStreaming
        streamingAgentMessage.showViewResultButton = true
        loadingMessage.progress = 100
        loadingMessage.content = '合同解析任务执行完毕！'
        finalizeWorkflowExecution({ output: finalResult.join('\n') }, addMessageCallback)
      }
    })
  } catch (error) {
    onExecutionError(error, loadingMessage, addMessageCallback)
  }
}
```

#### 乙供物资解析迁移

```javascript
// 原来：executeSupplierMaterialParsing() 调用 CozeParsingService  
// 改为：使用 agentManagementId: '3'

const executeSupplierMaterialParsing = async (inputs, context) => {
  const { workflow, loadingMessage, addMessageCallback } = context
  const finalResult = []

  const streamingAgentMessage = {
    id: Date.now() + Math.random(),
    from: 'agent',
    content: '',
    timestamp: new Date().toLocaleTimeString(),
    sender: workflow.name,
    workflow: { id: workflow.id, name: workflow.name },
    isStreaming: true
  }

  try {
    loadingMessage.content = '乙供物资解析已开始...'
    addMessageCallback(streamingAgentMessage)

    // 使用后端 API，agentManagementId: '3'
    await callStreamWorkflow(inputs, '3', {
      onMessage: (event) => {
        if (event.content) {
          chatStore.appendStreamContent(streamingAgentMessage.id, event.content)
          finalResult.push(event.content)
        }
      },
      onError: (error) => {
        onExecutionError(error, loadingMessage, addMessageCallback)
      },
      onComplete: () => {
        delete streamingAgentMessage.isStreaming
        streamingAgentMessage.showViewResultButton = true
        loadingMessage.progress = 100
        loadingMessage.content = '乙供物资解析任务执行完毕！'
        ElMessage.success('乙供物资解析完成')
        finalizeWorkflowExecution({ output: finalResult.join('\n') }, addMessageCallback)
      }
    })
  } catch (error) {
    onExecutionError(error, loadingMessage, addMessageCallback)
  }
}
```

### 第三步：文件上传统一化

所有工作流都使用 `uploadFile()` 而不是 `cozeWorkflowService.uploadFile()`：

```javascript
// src/stores/workflow.js 中的 uploadWorkflowFiles() 函数修改
const uploadWorkflowFiles = async () => {
  currentStepIndex.value = 0 // 步骤: 上传文件
  stepProgress.value = 0

  const uploadPromises = workflowConfig.files.map((file) => {
    // 统一使用后端上传接口，不再区分工作流类型
    return uploadFile(file.raw)
  })

  const fileResults = await Promise.all(uploadPromises)
  stepProgress.value = 100
  
  // 根据工作流类型格式化输入参数
  if (activeFunction.value === 'ownerSuppliedMaterialParsing') {
    // 甲供物资需要特殊的输入格式
    return fileResults.reduce((acc, file) => {
      const key = file.excel_type || 'other'
      if (key === 'other') {
        if (!acc[key]) acc[key] = []
        acc[key].push({ filePath: file.filePath })
      } else {
        acc[key] = file.filePath
      }
      return acc
    }, {})
  } else {
    // 合同解析和乙供物资解析使用统一格式
    return fileResults.map(result => ({ filePath: result.filePath }))
  }
}
```

### 第四步：更新工作流执行逻辑

```javascript
// 修改 executeWorkflow 函数中的 switch 语句
switch (func.id) {
  case 'contractParsing':
    executeContractParsing(inputs, context)
    break
  case 'supplierMaterialParsing':
    executeSupplierMaterialParsing(inputs, context)
    break
  case 'ownerSuppliedMaterialParsing':
    executeOwnerMaterialParsing(inputs, context)
    break
  default:
    throw new Error(`Unsupported function ID: ${func.id}`)
}
```

## 具体实施步骤

### 1. 立即收益（风险最小）
- **优先迁移合同解析**，因为它相对简单
- 保留原有 Coze 调用作为备选方案
- 验证迁移可行性

### 2. 中期优化  
- **迁移乙供物资解析**
- 统一错误处理和进度显示逻辑
- 完善测试用例

### 3. 长期清理
- 删除 `CozeParsingService.js` 和 `CozeWorkflowService.js` 
- 统一所有工作流使用 `backendWorkflow.js`
- 清理相关常量和配置

## 迁移后的架构优势

### 1. 架构统一
- 所有工作流都走后端 API，便于管控和监控
- 统一的调用模式和响应格式

### 2. 错误处理一致
- 统一的流式响应处理逻辑
- 标准化的错误信息展示

### 3. 扩展性强
- 后端可以添加权限验证、日志记录、数据持久化等
- 便于添加新的业务逻辑

### 4. 维护简单
- 只需要维护一套前端调用逻辑
- 减少代码重复，降低维护成本

### 5. 稳定性提升
- 减少对外部服务的直接依赖
- 更好的容错和重试机制

## 风险评估与注意事项

### 迁移风险
1. **API 兼容性**: 确保后端 API 完全兼容现有功能
2. **数据格式**: 注意输入输出数据格式的一致性
3. **性能影响**: 评估后端 API 的响应性能

### 测试策略
1. **功能测试**: 确保迁移后功能完全正常
2. **性能测试**: 对比迁移前后的性能差异
3. **错误处理测试**: 验证各种异常情况的处理

### 回滚计划
- 保留原有代码，便于快速回滚
- 通过配置开关控制新旧实现的切换

## 总结建议

**当前架构确实存在严重问题！** 三个类似功能使用两套完全不同的实现，这在任何系统中都是需要重构的技术债务。

### 强烈建议：

1. **立即规划迁移** - 不要继续在这种混乱架构上开发新功能
2. **先迁移合同解析** - 它最简单，可以验证迁移的可行性  
3. **逐步统一架构** - 最终目标是删除所有直接的 Coze API 调用
4. **完善文档** - 迁移过程中完善相关的 API 文档和使用说明

迁移完成后，系统将更加健壮、一致和可维护，为后续功能扩展奠定良好基础。

---

*分析时间：2025-08-10*
*分析人：Claude Code*